{"ast":null,"code":"module.exports = function (e) {\n  var t = {};\n  function n(r) {\n    if (t[r]) return t[r].exports;\n    var o = t[r] = {\n      i: r,\n      l: !1,\n      exports: {}\n    };\n    return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n  }\n  return n.m = e, n.c = t, n.d = function (e, t, r) {\n    n.o(e, t) || Object.defineProperty(e, t, {\n      enumerable: !0,\n      get: r\n    });\n  }, n.r = function (e) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, n.t = function (e, t) {\n    if (1 & t && (e = n(e)), 8 & t) return e;\n    if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n    var r = Object.create(null);\n    if (n.r(r), Object.defineProperty(r, \"default\", {\n      enumerable: !0,\n      value: e\n    }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(r, o, function (t) {\n      return e[t];\n    }.bind(null, o));\n    return r;\n  }, n.n = function (e) {\n    var t = e && e.__esModule ? function () {\n      return e.default;\n    } : function () {\n      return e;\n    };\n    return n.d(t, \"a\", t), t;\n  }, n.o = function (e, t) {\n    return Object.prototype.hasOwnProperty.call(e, t);\n  }, n.p = \"\", n(n.s = 1);\n}([function (e, t, n) {\n  \"use strict\";\n\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.DBMode = t.DBOperations = t.CreateObjectStore = t.openDatabase = void 0;\n  var r,\n    o = n(4),\n    a = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n  function i(e, t, n) {\n    return new Promise(function (r, o) {\n      var i,\n        c = a.open(e, t);\n      c.onsuccess = function (e) {\n        i = c.result, r(i);\n      }, c.onerror = function (e) {\n        o(\"IndexedDB error: \" + c.error);\n      }, \"function\" == typeof n && (c.onupgradeneeded = function (e) {\n        n(e, i);\n      });\n    });\n  }\n  t.openDatabase = i, t.CreateObjectStore = function (e, t, n) {\n    var r = a.open(e, t);\n    r.onupgradeneeded = function (e) {\n      var t = e.target.result;\n      n.forEach(function (e) {\n        if (!t.objectStoreNames.contains(e.store)) {\n          var n = t.createObjectStore(e.store, e.storeConfig);\n          e.storeSchema.forEach(function (e) {\n            n.createIndex(e.name, e.keypath, e.options);\n          });\n        }\n      }), t.close();\n    }, r.onsuccess = function (e) {\n      e.target.result.close();\n    };\n  }, t.DBOperations = function (e, t, n) {\n    return {\n      add: function (a, c) {\n        return new Promise(function (u, s) {\n          i(e, t).then(function (e) {\n            o.createTransaction(e, o.optionsGenerator(r.readwrite, n, s, u)).objectStore(n).add(a, c).onsuccess = function (e) {\n              c = e.target.result, u(c);\n            };\n          });\n        });\n      },\n      getByID: function (a) {\n        return new Promise(function (c, u) {\n          i(e, t).then(function (e) {\n            o.validateBeforeTransaction(e, n, u), o.createTransaction(e, o.optionsGenerator(r.readonly, n, u, c)).objectStore(n).get(+a).onsuccess = function (e) {\n              c(e.target.result);\n            };\n          });\n        });\n      },\n      getAll: function () {\n        return new Promise(function (a, c) {\n          i(e, t).then(function (e) {\n            o.validateBeforeTransaction(e, n, c);\n            var t = o.createTransaction(e, o.optionsGenerator(r.readonly, n, c, a)).objectStore(n).getAll();\n            t.onerror = function (e) {\n              c(e);\n            }, t.onsuccess = function (e) {\n              var t = e.target.result;\n              a(t);\n            };\n          });\n        });\n      },\n      update: function (a, c) {\n        return new Promise(function (u, s) {\n          i(e, t).then(function (e) {\n            o.validateBeforeTransaction(e, n, s);\n            var t = o.createTransaction(e, o.optionsGenerator(r.readwrite, n, s, u)),\n              i = t.objectStore(n);\n            t.oncomplete = function (e) {\n              u(e);\n            }, i.put(a, c);\n          });\n        });\n      },\n      deleteRecord: function (a) {\n        return new Promise(function (c, u) {\n          i(e, t).then(function (e) {\n            o.validateBeforeTransaction(e, n, u), o.createTransaction(e, o.optionsGenerator(r.readwrite, n, u, c)).objectStore(n).delete(a).onsuccess = function (e) {\n              c(e);\n            };\n          });\n        });\n      },\n      clear: function () {\n        return new Promise(function (a, c) {\n          i(e, t).then(function (e) {\n            o.validateBeforeTransaction(e, n, c);\n            var t = o.createTransaction(e, o.optionsGenerator(r.readwrite, n, c, a));\n            t.objectStore(n).clear(), t.oncomplete = function (e) {\n              a();\n            };\n          });\n        });\n      },\n      openCursor: function (a, c) {\n        return new Promise(function (u, s) {\n          i(e, t).then(function (e) {\n            o.validateBeforeTransaction(e, n, s), o.createTransaction(e, o.optionsGenerator(r.readonly, n, s, u)).objectStore(n).openCursor(c).onsuccess = function (e) {\n              a(e), u();\n            };\n          });\n        });\n      },\n      getByIndex: function (a, c) {\n        return new Promise(function (u, s) {\n          i(e, t).then(function (e) {\n            o.validateBeforeTransaction(e, n, s), o.createTransaction(e, o.optionsGenerator(r.readonly, n, s, u)).objectStore(n).index(a).get(c).onsuccess = function (e) {\n              u(e.target.result);\n            };\n          });\n        });\n      }\n    };\n  }, function (e) {\n    e.readonly = \"readonly\", e.readwrite = \"readwrite\";\n  }(r = t.DBMode || (t.DBMode = {}));\n}, function (e, t, n) {\n  \"use strict\";\n\n  var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n      void 0 === r && (r = n), Object.defineProperty(e, r, {\n        enumerable: !0,\n        get: function () {\n          return t[n];\n        }\n      });\n    } : function (e, t, n, r) {\n      void 0 === r && (r = n), e[r] = t[n];\n    }),\n    o = this && this.__exportStar || function (e, t) {\n      for (var n in e) \"default\" === n || t.hasOwnProperty(n) || r(t, e, n);\n    };\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var a = n(2);\n  Object.defineProperty(t, \"AccessDB\", {\n    enumerable: !0,\n    get: function () {\n      return a.AccessDB;\n    }\n  }), Object.defineProperty(t, \"IndexedDB\", {\n    enumerable: !0,\n    get: function () {\n      return a.IndexedDB;\n    }\n  }), o(n(5), t);\n}, function (e, t, n) {\n  \"use strict\";\n\n  var r = this && this.__assign || function () {\n      return (r = Object.assign || function (e) {\n        for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n        return e;\n      }).apply(this, arguments);\n    },\n    o = this && this.__awaiter || function (e, t, n, r) {\n      return new (n || (n = Promise))(function (o, a) {\n        function i(e) {\n          try {\n            u(r.next(e));\n          } catch (e) {\n            a(e);\n          }\n        }\n        function c(e) {\n          try {\n            u(r.throw(e));\n          } catch (e) {\n            a(e);\n          }\n        }\n        function u(e) {\n          var t;\n          e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n            e(t);\n          })).then(i, c);\n        }\n        u((r = r.apply(e, t || [])).next());\n      });\n    },\n    a = this && this.__generator || function (e, t) {\n      var n,\n        r,\n        o,\n        a,\n        i = {\n          label: 0,\n          sent: function () {\n            if (1 & o[0]) throw o[1];\n            return o[1];\n          },\n          trys: [],\n          ops: []\n        };\n      return a = {\n        next: c(0),\n        throw: c(1),\n        return: c(2)\n      }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function () {\n        return this;\n      }), a;\n      function c(a) {\n        return function (c) {\n          return function (a) {\n            if (n) throw new TypeError(\"Generator is already executing.\");\n            for (; i;) try {\n              if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;\n              switch (r = 0, o && (a = [2 & a[0], o.value]), a[0]) {\n                case 0:\n                case 1:\n                  o = a;\n                  break;\n                case 4:\n                  return i.label++, {\n                    value: a[1],\n                    done: !1\n                  };\n                case 5:\n                  i.label++, r = a[1], a = [0];\n                  continue;\n                case 7:\n                  a = i.ops.pop(), i.trys.pop();\n                  continue;\n                default:\n                  if (!(o = i.trys, (o = o.length > 0 && o[o.length - 1]) || 6 !== a[0] && 2 !== a[0])) {\n                    i = 0;\n                    continue;\n                  }\n                  if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {\n                    i.label = a[1];\n                    break;\n                  }\n                  if (6 === a[0] && i.label < o[1]) {\n                    i.label = o[1], o = a;\n                    break;\n                  }\n                  if (o && i.label < o[2]) {\n                    i.label = o[2], i.ops.push(a);\n                    break;\n                  }\n                  o[2] && i.ops.pop(), i.trys.pop();\n                  continue;\n              }\n              a = t.call(e, i);\n            } catch (e) {\n              a = [6, e], r = 0;\n            } finally {\n              n = o = 0;\n            }\n            if (5 & a[0]) throw a[1];\n            return {\n              value: a[0] ? a[1] : void 0,\n              done: !0\n            };\n          }([a, c]);\n        };\n      }\n    },\n    i = this && this.__importDefault || function (e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    };\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.AccessDB = t.IndexedDB = void 0;\n  var c = i(n(3)),\n    u = n(0),\n    s = c.default.createContext({\n      db: null,\n      name: null,\n      version: null\n    }),\n    f = s.Provider,\n    l = s.Consumer;\n  t.IndexedDB = function (e) {\n    var t = this,\n      n = e.name,\n      r = e.version,\n      i = e.children;\n    return e.objectStoresMeta.forEach(function (e) {\n      return o(t, void 0, void 0, function () {\n        return a(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, u.openDatabase(n, r, function (t) {\n                var n = t.currentTarget.result.createObjectStore(e.store, e.storeConfig);\n                e.storeSchema.forEach(function (e) {\n                  n.createIndex(e.name, e.keypath, e.options);\n                });\n              })];\n            case 1:\n              return t.sent(), [2];\n          }\n        });\n      });\n    }), c.default.createElement(f, {\n      value: {\n        db: null,\n        name: n,\n        version: r\n      }\n    }, i);\n  }, t.AccessDB = function (e) {\n    var t = e.children,\n      n = e.objectStore;\n    return c.default.createElement(l, null, function (e) {\n      var o = e.db,\n        a = e.name,\n        i = e.version;\n      return t(r({\n        db: o\n      }, u.DBOperations(a, i, n)));\n    });\n  };\n}, function (e, t) {\n  e.exports = require(\"react\");\n}, function (e, t, n) {\n  \"use strict\";\n\n  function r(e, t) {\n    return e.objectStoreNames.contains(t);\n  }\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.optionsGenerator = t.createTransaction = t.validateBeforeTransaction = t.validateStoreName = void 0, t.validateStoreName = r, t.validateBeforeTransaction = function (e, t, n) {\n    e || n(\"You need to use the openDatabase function to create a database before you query it!\"), r(e, t) || n(\"objectStore does not exists: \" + t);\n  }, t.createTransaction = function (e, t) {\n    var n = e.transaction(t.storeName, t.dbMode);\n    return n.onerror = t.error, n.oncomplete = t.complete, n.onabort = t.abort, n;\n  }, t.optionsGenerator = function (e, t, n, r) {\n    return {\n      storeName: t,\n      dbMode: e,\n      error: function (e) {\n        n(e);\n      },\n      complete: function (e) {\n        r();\n      },\n      abort: function (e) {\n        n(e);\n      }\n    };\n  };\n}, function (e, t, n) {\n  \"use strict\";\n\n  var r = this && this.__assign || function () {\n    return (r = Object.assign || function (e) {\n      for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n      return e;\n    }).apply(this, arguments);\n  };\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.useIndexedDB = t.initDB = void 0;\n  var o = n(0),\n    a = {\n      version: null,\n      name: null\n    };\n  t.initDB = function (e) {\n    var t = e.name,\n      n = e.version,\n      r = e.objectStoresMeta;\n    a.name = t, a.version = n, Object.freeze(a), o.CreateObjectStore(t, n, r);\n  }, t.useIndexedDB = function (e) {\n    if (!a.name || !a.version) throw new Error(\"Please, initialize the DB before the use.\");\n    return r({}, o.DBOperations(a.name, a.version, e));\n  };\n}]);","map":{"version":3,"mappings":"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","names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","DBMode","indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","openDatabase","dbName","version","upgradeCallback","Promise","resolve","reject","db","request","open","onsuccess","event","result","onerror","error","onupgradeneeded","storeSchemas","database","target","forEach","storeSchema","objectStoreNames","contains","store","createObjectStore","storeConfig","schema","createIndex","keypath","options","close","e","currentStore","add","then","readwrite","objectStore","evt","getByID","id","readonly","getAll","update","transaction","oncomplete","put","deleteRecord","delete","clear","openCursor","cursorCallback","keyRange","getByIndex","indexName","index","AccessDB","IndexedDB","u","IndexedDBContext","createContext","IndexedDBProvider","Provider","IndexedDBCosumer","Consumer","children","currentTarget","require","validateStoreName","storeName","trans","dbMode","complete","onabort","abort","type","indexeddbConfiguration","objectStoresMeta","freeze","Error"],"sources":["webpack:///webpack/bootstrap","webpack:///src/indexed-db.ts","webpack:///src/index.tsx","webpack:///src/indexed-context.tsx","webpack:///external \"react\"","webpack:///src/Utils.ts","webpack:///src/indexed-hooks.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import { validateBeforeTransaction, createTransaction, optionsGenerator } from './Utils';\nimport { ObjectStoreMeta, ObjectStoreSchema } from './indexed-hooks';\n\nexport type Key = string | number | Date | ArrayBufferView | ArrayBuffer | IDBArrayKey | IDBKeyRange;\nexport interface IndexDetails {\n  indexName: string;\n  order: string;\n}\nconst indexedDB: IDBFactory =\n  window.indexedDB || (<any>window).mozIndexedDB || (<any>window).webkitIndexedDB || (<any>window).msIndexedDB;\n\nexport function openDatabase(dbName: string, version: number, upgradeCallback?: Function) {\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    const request = indexedDB.open(dbName, version);\n    let db: IDBDatabase;\n    request.onsuccess = (event: Event) => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = (event: Event) => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = (event: Event) => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\n\nexport function CreateObjectStore(dbName: string, version: number, storeSchemas: ObjectStoreMeta[]) {\n  const request: IDBOpenDBRequest = indexedDB.open(dbName, version);\n\n  request.onupgradeneeded = function(event: IDBVersionChangeEvent) {\n    const database: IDBDatabase = (event.target as any).result;\n    storeSchemas.forEach((storeSchema: ObjectStoreMeta) => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n        storeSchema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n    database.close();\n  };\n  request.onsuccess = function(e: any) {\n    e.target.result.close();\n  };\n}\n\nexport function DBOperations(dbName: string, version: number, currentStore: string) {\n  return {\n    add<T>(value: T, key?: any) {\n      return new Promise<number>((resolve, reject) => {\n        openDatabase(dbName, version).then((db: IDBDatabase) => {\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore);\n          let request = objectStore.add(value, key);\n          request.onsuccess = (evt: any) => {\n            key = evt.target.result;\n            resolve(key);\n          };\n        });\n      });\n    },\n    getByID<T>(id: string | number) {\n      return new Promise<T>((resolve, reject) => {\n        openDatabase(dbName, version).then((db: IDBDatabase) => {\n          validateBeforeTransaction(db, currentStore, reject);\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readonly, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore),\n            request: IDBRequest;\n          request = objectStore.get(+id);\n          request.onsuccess = function(event: Event) {\n            resolve((event.target as any).result as T);\n          };\n        });\n      });\n    },\n    getAll<T>() {\n      return new Promise<T[]>((resolve, reject) => {\n        openDatabase(dbName, version).then(db => {\n          validateBeforeTransaction(db, currentStore, reject);\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readonly, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore),\n            result: Array<any> = [];\n\n          const request: IDBRequest = objectStore.getAll();\n\n          request.onerror = function(e) {\n            reject(e);\n          };\n\n          request.onsuccess = function({ target: { result } }: any) {\n            resolve(result as T[]);\n          };\n        });\n      });\n    },\n    update<T>(value: T, key?: any) {\n      return new Promise<any>((resolve, reject) => {\n        openDatabase(dbName, version).then(db => {\n          validateBeforeTransaction(db, currentStore, reject);\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore);\n          transaction.oncomplete = event => {\n            resolve(event);\n          };\n          objectStore.put(value, key);\n        });\n      });\n    },\n    deleteRecord(key: Key) {\n      return new Promise<any>((resolve, reject) => {\n        openDatabase(dbName, version).then(db => {\n          validateBeforeTransaction(db, currentStore, reject);\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore);\n          let request = objectStore.delete(key);\n          request.onsuccess = event => {\n            resolve(event);\n          };\n        });\n      });\n    },\n    clear() {\n      return new Promise<any>((resolve, reject) => {\n        openDatabase(dbName, version).then(db => {\n          validateBeforeTransaction(db, currentStore, reject);\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore);\n          objectStore.clear();\n          transaction.oncomplete = event => {\n            resolve();\n          };\n        });\n      });\n    },\n    openCursor(cursorCallback: (event: Event) => void, keyRange?: IDBKeyRange) {\n      return new Promise<void>((resolve, reject) => {\n        openDatabase(dbName, version).then(db => {\n          validateBeforeTransaction(db, currentStore, reject);\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readonly, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore),\n            request = objectStore.openCursor(keyRange);\n\n          request.onsuccess = (event: Event) => {\n            cursorCallback(event);\n            resolve();\n          };\n        });\n      });\n    },\n    getByIndex(indexName: string, key: any) {\n      return new Promise<any>((resolve, reject) => {\n        openDatabase(dbName, version).then(db => {\n          validateBeforeTransaction(db, currentStore, reject);\n          let transaction = createTransaction(db, optionsGenerator(DBMode.readonly, currentStore, reject, resolve)),\n            objectStore = transaction.objectStore(currentStore),\n            index = objectStore.index(indexName),\n            request = index.get(key);\n          request.onsuccess = (event: Event) => {\n            resolve((<IDBOpenDBRequest>event.target).result);\n          };\n        });\n      });\n    }\n  };\n}\n\nexport enum DBMode {\n  readonly = 'readonly',\n  readwrite = 'readwrite'\n}\n","export { AccessDB, IndexedDB } from './indexed-context';\nexport * from './indexed-hooks';\n","import React, { ReactNode } from 'react';\nimport { DBOperations, openDatabase, Key } from './indexed-db';\n\ninterface IndexedDBProps {\n  name: string;\n  version: number;\n  children: ReactNode;\n  objectStoresMeta: ObjectStoreMeta[];\n}\n\ninterface ObjectStoreMeta {\n  store: string;\n  storeConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n  storeSchema: ObjectStoreSchema[];\n}\n\ninterface ObjectStoreSchema {\n  name: string;\n  keypath: string;\n  options: { unique: boolean; [key: string]: any };\n}\n\nconst IndexedDBContext = React.createContext<{ db: any; name: string; version: number }>({\n  db: null,\n  name: null,\n  version: null\n});\n\nconst IndexedDBProvider = IndexedDBContext.Provider;\nconst IndexedDBCosumer = IndexedDBContext.Consumer;\n\nexport function IndexedDB({ name, version, children, objectStoresMeta }: IndexedDBProps) {\n  objectStoresMeta.forEach(async (schema: ObjectStoreMeta) => {\n    const db = await openDatabase(name, version, (event: any) => {\n      let db: IDBDatabase = event.currentTarget.result;\n      let objectStore = db.createObjectStore(schema.store, schema.storeConfig);\n      schema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n        objectStore.createIndex(schema.name, schema.keypath, schema.options);\n      });\n    });\n  });\n  return <IndexedDBProvider value={{ db: null, name, version }}>{children}</IndexedDBProvider>;\n}\n\ninterface AccessDBProps {\n  children: ({\n    db\n  }: {\n    db: IDBDatabase;\n    add: <T = any>(value: T, key?: any) => Promise<number>;\n    getByID: <T = any>(id: number | string) => Promise<T>;\n    getAll: <T = any>() => Promise<T[]>;\n    update: <T = any>(value: T, key?: any) => Promise<any>;\n    deleteRecord: (key: Key) => Promise<any>;\n    openCursor: (cursorCallback: (event: Event) => void, keyRange?: IDBKeyRange) => Promise<void>;\n    getByIndex: (indexName: string, key: any) => Promise<any>;\n    clear: () => Promise<any>;\n  }) => {};\n  objectStore: string;\n}\n\nexport function AccessDB({ children, objectStore }: AccessDBProps) {\n  return (\n    <IndexedDBCosumer>\n      {value => {\n        const { db, name, version } = value;\n        // openDatabase(name, version);\n        return children({ db, ...DBOperations(name, version, objectStore) });\n      }}\n    </IndexedDBCosumer>\n  );\n}\n","module.exports = require(\"react\");","export interface Options {\n  storeName: string;\n  dbMode: IDBTransactionMode;\n  error: (e: Event) => any;\n  complete: (e: Event) => any;\n  abort?: any;\n}\n\nexport function validateStoreName(db: IDBDatabase, storeName: string) {\n  return db.objectStoreNames.contains(storeName);\n}\n\nexport function validateBeforeTransaction(db: IDBDatabase, storeName: string, reject: Function) {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\n\nexport function createTransaction(db: IDBDatabase, options: Options): IDBTransaction {\n  let trans: IDBTransaction = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.oncomplete = options.complete;\n  trans.onabort = options.abort;\n  return trans;\n}\n\nexport function optionsGenerator(type: any, storeName: any, reject: Function, resolve: Function): Options {\n  return {\n    storeName: storeName,\n    dbMode: type,\n    error: (e: Event) => {\n      reject(e);\n    },\n    complete: (e: Event) => {\n      resolve();\n    },\n    abort: (e: Event) => {\n      reject(e);\n    }\n  };\n}\n\n// export function* processRequest({ request, success, error }: any) {\n//   request.onerror = function(event: Event) {\n//     error(error);\n//     yield error;\n//   };\n//   request.onsuccess = function(evt: Event) {\n//     let cursor: IDBCursorWithValue = (<IDBRequest>evt.target).result;\n//     if (cursor) {\n//       result.push(cursor.value);\n//       cursor.continue();\n//     } else {\n//       resolve(result);\n//     }\n//   };\n// }\n","import { DBOperations, openDatabase, Key, CreateObjectStore } from './indexed-db';\n\nexport interface IndexedDBProps {\n  name: string;\n  version: number;\n  objectStoresMeta: ObjectStoreMeta[];\n}\n\nexport interface ObjectStoreMeta {\n  store: string;\n  storeConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n  storeSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n  name: string;\n  keypath: string;\n  options: { unique: boolean; [key: string]: any };\n}\n\nexport interface useIndexedDB {\n  dbName: string;\n  version: number;\n  objectStore: string;\n}\n\nlet indexeddbConfiguration: { version: number; name: string } = { version: null, name: null };\n\nexport function initDB({ name, version, objectStoresMeta }: IndexedDBProps) {\n  indexeddbConfiguration.name = name;\n  indexeddbConfiguration.version = version;\n  Object.freeze(indexeddbConfiguration);\n  CreateObjectStore(name, version, objectStoresMeta);\n}\n\nexport function useIndexedDB(\n  objectStore: string\n): {\n  add: <T = any>(value: T, key?: any) => Promise<number>;\n  getByID: <T = any>(id: number | string) => Promise<T>;\n  getAll: <T = any>() => Promise<T[]>;\n  update: <T = any>(value: T, key?: any) => Promise<any>;\n  deleteRecord: (key: Key) => Promise<any>;\n  openCursor: (cursorCallback: (event: Event) => void, keyRange?: IDBKeyRange) => Promise<void>;\n  getByIndex: (indexName: string, key: any) => Promise<any>;\n  clear: () => Promise<any>;\n} {\n  if (!indexeddbConfiguration.name || !indexeddbConfiguration.version) {\n    throw new Error('Please, initialize the DB before the use.');\n  }\n  return { ...DBOperations(indexeddbConfiguration.name, indexeddbConfiguration.version, objectStore) };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}